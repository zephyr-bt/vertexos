<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Overflow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@500;800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #09090b; font-family: 'JetBrains Mono', monospace; user-select: none; }
        canvas { display: block; }
        
        /* UI OVERLAY */
        #ui {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-col; justify-content: center; align-items: center;
        }
        
        /* SCORE */
        #score-board {
            position: absolute; top: 10%; 
            font-size: 80px; font-weight: 800; color: rgba(255,255,255,0.2);
            transition: 0.2s; text-shadow: 0 0 30px rgba(255,255,255,0.1);
        }
        
        /* MENU SCREEN */
        #menu {
            pointer-events: auto; text-align: center;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(20px);
            padding: 40px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            transform: scale(0.9); opacity: 0; transition: 0.3s; pointer-events: none;
        }
        #menu.visible { transform: scale(1); opacity: 1; pointer-events: auto; }

        .btn-start {
            margin-top: 20px; padding: 12px 32px; font-size: 16px; font-weight: bold;
            background: #fff; color: #000; border-radius: 12px; cursor: pointer;
            transition: 0.2s; box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(255,255,255,0.5); }
        .btn-start:active { transform: scale(0.95); }

    </style>
</head>
<body>

    <canvas id="game"></canvas>

    <div id="ui">
        <div id="score-board">0</div>
        
        <div id="menu" class="visible">
            <div class="mb-4">
                <i data-lucide="layers" class="w-12 h-12 text-blue-500 mx-auto mb-2"></i>
                <h1 class="text-3xl font-bold text-white mb-1">STACK OVERFLOW</h1>
                <p class="text-xs text-gray-400">Precision Architecture</p>
            </div>
            <div id="final-score" class="text-sm text-gray-300 mb-4 hidden">Score: 0</div>
            <button class="btn-start" onclick="startGame()">START BUILD</button>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- ENGINE CONFIG ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-board');
        const menuEl = document.getElementById('menu');
        
        // Colors (Vertex Theme)
        const COLORS = {
            bg: '#09090b',
            base: '#3b82f6',
            flash: '#ffffff'
        };

        // Game State
        let state = {
            playing: false,
            score: 0,
            blocks: [],
            current: null,
            speed: 3,
            direction: 1, // 1 = right, -1 = left
            cameraY: 0,
            hue: 200
        };

        // Constants
        const INITIAL_WIDTH = 200;
        const HEIGHT = 30;
        const START_Y = 600;

        // --- RESIZE ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(!state.playing) renderTitleScreen();
        }
        window.addEventListener('resize', resize);

        // --- GAME LOOP ---
        function startGame() {
            state.playing = true;
            state.score = 0;
            state.blocks = [];
            state.speed = 4;
            state.direction = 1;
            state.cameraY = 0;
            state.hue = 200; // Start Blue
            
            scoreEl.innerText = "0";
            scoreEl.style.color = "rgba(255,255,255,0.2)";
            menuEl.classList.remove('visible');

            // Base Block
            addBlock(canvas.width/2 - INITIAL_WIDTH/2, START_Y, INITIAL_WIDTH);
            
            // First Moving Block
            spawnNextBlock();
            
            loop();
        }

        function spawnNextBlock() {
            const prevBlock = state.blocks[state.blocks.length - 1];
            
            state.current = {
                x: -200, // Start off screen
                y: prevBlock.y - HEIGHT,
                w: prevBlock.w,
                h: HEIGHT,
                color: `hsl(${state.hue}, 80%, 60%)`
            };
            
            // Increment difficulty
            state.hue += 5; 
            state.speed += 0.1;
        }

        function loop() {
            if (!state.playing) return;

            update();
            draw();
            requestAnimationFrame(loop);
        }

        // --- LOGIC ---
        function update() {
            if (!state.current) return;

            // Move Block
            state.current.x += state.speed * state.direction;

            // Bounce off walls (Safety, though user should click before this)
            if (state.current.x > canvas.width || state.current.x + state.current.w < 0) {
               // In a real game, maybe lose? For now, wrap or bounce. Let's bounce to be nice.
               state.direction *= -1;
            }
        }

        // --- INPUT ---
        window.addEventListener('mousedown', placeBlock);
        window.addEventListener('keydown', (e) => { if(e.code === 'Space') placeBlock() });

        function placeBlock() {
            if (!state.playing || !state.current) return;

            const curr = state.current;
            const prev = state.blocks[state.blocks.length - 1];

            const dist = curr.x - prev.x;
            const overlap = prev.w - Math.abs(dist);

            if (overlap > 0) {
                // SUCCESS: Cut the block
                const cutX = dist > 0 ? curr.x + overlap : curr.x;
                const cutW = Math.abs(dist); // The part that falls off
                
                // Update Current Block to only the overlapped part
                curr.w = overlap;
                curr.x = dist > 0 ? curr.x : prev.x;

                state.blocks.push(curr);
                state.score++;
                scoreEl.innerText = state.score;
                
                // Visual Flash
                scoreEl.style.color = "white";
                setTimeout(() => scoreEl.style.color = "rgba(255,255,255,0.2)", 100);

                // Move Camera if getting high
                const targetY = canvas.height - 200;
                if (curr.y < targetY) {
                    state.cameraY += HEIGHT;
                }

                spawnNextBlock();

            } else {
                // GAME OVER
                gameOver();
            }
        }

        function gameOver() {
            state.playing = false;
            menuEl.classList.add('visible');
            document.getElementById('final-score').innerText = `Final Height: ${state.score} Blocks`;
            document.getElementById('final-score').classList.remove('hidden');
        }

        function addBlock(x, y, w) {
            state.blocks.push({
                x, y, w, h: HEIGHT,
                color: COLORS.base
            });
        }

        // --- RENDER ---
        function draw() {
            // Clear & Background
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            // Camera Shake/Move
            ctx.translate(0, state.cameraY);

            // Draw Placed Blocks
            state.blocks.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = b.color;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                
                // Top Highlight (Pseudo 3D)
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(b.x, b.y, b.w, 4);
                
                ctx.shadowBlur = 0; // Reset shadow for next ops
            });

            // Draw Moving Block
            if (state.current) {
                const c = state.current;
                ctx.fillStyle = c.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = c.color;
                ctx.fillRect(c.x, c.y, c.w, c.h);
                
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(c.x, c.y, c.w, 4);
            }

            ctx.restore();
        }

        function renderTitleScreen() {
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Init
        resize();

    </script>
</body>
</html>
