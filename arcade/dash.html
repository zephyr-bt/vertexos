<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Dash | GD Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'JetBrains Mono', monospace; user-select: none; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; width: 100%; height: 100%; }

        /* UI OVERLAY */
        #ui { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; }

        /* HUD */
        #score-box {
            position: absolute; top: 10%; 
            font-size: 40px; font-weight: 800; color: white;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
            font-style: italic;
        }

        /* MENU */
        #menu {
            pointer-events: auto; text-align: center;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
            padding: 40px 60px; border-radius: 20px; border: 2px solid rgba(255,255,255,0.1);
            transform: scale(0.9); opacity: 0; transition: 0.2s; pointer-events: none;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
        }
        #menu.visible { transform: scale(1); opacity: 1; pointer-events: auto; }

        .btn-play {
            margin-top: 30px; width: 90px; height: 90px; border-radius: 50%;
            background: linear-gradient(135deg, #00ff00, #00aa00); 
            border: 4px solid #fff; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 30px rgba(0,255,0,0.6); transition: 0.1s;
        }
        .btn-play:active { transform: scale(0.9); filter: brightness(0.8); }

        /* DEATH FLASH */
        #flash {
            position: absolute; inset: 0; background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50;
        }
    </style>
</head>
<body>

    <canvas id="game"></canvas>
    <div id="flash"></div>

    <div id="ui">
        <div id="score-box">0%</div>
        
        <div id="menu" class="visible">
            <h1 class="text-5xl font-black text-white mb-1 italic tracking-tighter" style="text-shadow: 4px 4px 0 #00aa00;">GEOMETRY<br>DASH</h1>
            <p class="text-green-400 text-xs tracking-[0.3em] font-bold">VERTEX EDITION</p>
            
            <div id="death-msg" class="text-white font-bold mt-4 hidden bg-red-600 px-4 py-1 rounded text-sm uppercase tracking-widest">Attempt 1</div>
            
            <div class="flex justify-center relative z-50">
                <button id="start-btn" class="btn-play" onclick="resetGame(event)">
                    <i data-lucide="play" class="w-10 h-10 fill-white text-white ml-1"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-box');
        const menu = document.getElementById('menu');
        const flash = document.getElementById('flash');
        const deathMsg = document.getElementById('death-msg');

        // --- GD PHYSICS CONFIG ---
        const GRAVITY = 0.9;         // Heavy, crisp gravity
        const JUMP_FORCE = -14.5;    // Snappy jump
        const SPEED = 9;             // Constant scroll speed
        let FLOOR = 0;
        let ATTEMPTS = 1;

        // COLORS
        const BG_COLOR = "#0055aa";  // Classic Blue BG
        const GRID_COLOR = "rgba(255,255,255,0.1)";
        const FLOOR_COLOR = "#002244";

        let state = {
            running: false,
            score: 0,
            frames: 0,
            bgOffset: 0,
            player: { 
                x: 100, y: 0, size: 40, 
                dy: 0, angle: 0, grounded: false, 
                trail: [] // Array of past positions
            },
            obstacles: [],
            particles: []
        };

        // --- SETUP ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            FLOOR = canvas.height - 150; 
            if(!state.running) drawStatic();
        }
        window.addEventListener('resize', resize);

        function resetGame(e) {
            if(e) e.stopPropagation(); // Stop click from firing jump immediately

            state.running = true;
            state.score = 0;
            state.frames = 0;
            state.bgOffset = 0;
            
            // Reset Player
            state.player.y = FLOOR - 40;
            state.player.dy = 0;
            state.player.angle = 0;
            state.player.trail = [];
            
            state.obstacles = [];
            state.particles = [];
            
            scoreEl.innerText = "0%";
            menu.classList.remove('visible');
            deathMsg.classList.add('hidden');
            
            loop();
        }

        // --- GAME LOOP ---
        function loop() {
            if(!state.running) return;
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            const p = state.player;
            state.frames++;
            state.bgOffset -= SPEED * 0.5; // Parallax Grid

            // --- PHYSICS ---
            p.dy += GRAVITY;
            p.y += p.dy;

            // Rotation Logic (Spin in air, snap on ground)
            if(!p.grounded) {
                p.angle += 0.12; // Spin speed
            } else {
                // Snap to nearest 90 degrees (PI/2)
                const snap = Math.round(p.angle / (Math.PI/2)) * (Math.PI/2);
                p.angle = snap; 
            }

            // Floor Collision
            if(p.y + p.size >= FLOOR) {
                if(!p.grounded) {
                    // Just landed
                    spawnSquareParticles(p.x + p.size/2, FLOOR, 5, '#fff');
                }
                p.y = FLOOR - p.size;
                p.dy = 0;
                p.grounded = true;
            } else {
                p.grounded = false;
            }

            // --- TRAIL LOGIC ---
            // Add current pos to trail
            if(state.frames % 2 === 0) { // Optimize: add every 2nd frame
                p.trail.push({x: p.x, y: p.y, angle: p.angle, life: 1.0});
            }
            // Update trail life
            for(let i=p.trail.length-1; i>=0; i--) {
                p.trail[i].x -= SPEED; // Move trail with world? No, visual trail stays relative to screen usually, but player stays still in X.
                // Actually, in auto-runners, objects move LEFT. Player X is static.
                // So trail just fades in place.
                p.trail[i].life -= 0.05;
                if(p.trail[i].life <= 0) p.trail.splice(i, 1);
            }

            // --- LEVEL GENERATION (Procedural) ---
            if(state.frames % 60 === 0) { // Every 1 second approx
                // Random pattern
                const rand = Math.random();
                
                if (rand < 0.3) {
                    // Single Spike
                    spawnObstacle('spike', 0);
                } else if (rand < 0.6) {
                    // Block
                    spawnObstacle('block', 0);
                } else if (rand < 0.8) {
                    // Triple Spike (Hard)
                    spawnObstacle('spike', 0);
                    spawnObstacle('spike', 40);
                    spawnObstacle('spike', 80);
                }
            }

            // --- UPDATE OBSTACLES ---
            for(let i = state.obstacles.length - 1; i >= 0; i--) {
                const obs = state.obstacles[i];
                obs.x -= SPEED;

                // Collision Detection (Hitbox Shrink for fairness)
                const hitX = obs.x + 5;
                const hitY = obs.y + 5;
                const hitW = obs.w - 10;
                const hitH = obs.h - 10;
                
                const pX = p.x + 5;
                const pY = p.y + 5;
                const pS = p.size - 10;

                if (pX < hitX + hitW &&
                    pX + pS > hitX &&
                    pY < hitY + hitH &&
                    pY + pS > hitY) {
                    gameOver();
                }

                // Remove off-screen
                if(obs.x + obs.w < 0) state.obstacles.splice(i, 1);
            }

            // Score (Based on distance)
            state.score++;
            if(state.score % 10 === 0) scoreEl.innerText = Math.floor(state.score / 100) + "%";

            // Update Particles
            updateParticles();
        }

        function spawnObstacle(type, xOffset) {
            state.obstacles.push({
                x: canvas.width + xOffset,
                y: type === 'spike' ? FLOOR - 40 : FLOOR - 40, // Block sits on ground
                w: 40, h: 40,
                type: type
            });
        }

        function spawnSquareParticles(x, y, count, color) {
            for(let i=0; i<count; i++) {
                state.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 10 + 5,
                    life: 1.0, color: color
                });
            }
        }

        function updateParticles() {
            for(let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                p.size *= 0.95; // Shrink
                if(p.life <= 0) state.particles.splice(i, 1);
            }
        }

        function gameOver() {
            state.running = false;
            
            // DEATH EFFECT: Explode player into square particles
            spawnSquareParticles(state.player.x + 20, state.player.y + 20, 20, '#ffff00'); // Yellow
            spawnSquareParticles(state.player.x + 20, state.player.y + 20, 20, '#00ffff'); // Cyan
            
            draw(); // Render one last frame with explosion
            
            flash.style.opacity = 1;
            setTimeout(() => flash.style.opacity = 0, 100);

            setTimeout(() => {
                ATTEMPTS++;
                deathMsg.innerText = `Attempt ${ATTEMPTS}`;
                menu.classList.add('visible');
                deathMsg.classList.remove('hidden');
            }, 600);
        }

        // --- DRAWING ---
        function draw() {
            // 1. Background (Gradient)
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0, BG_COLOR);
            grd.addColorStop(1, "#002244");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Moving Grid Background
            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = 2;
            const gridSize = 100;
            const offsetX = state.bgOffset % gridSize;
            
            ctx.beginPath();
            // Vertical Lines
            for(let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
            }
            // Horizontal Lines
            for(let y = 0; y < canvas.height; y += gridSize) {
                ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // 3. Floor
            ctx.fillStyle = FLOOR_COLOR;
            ctx.fillRect(0, FLOOR, canvas.width, canvas.height - FLOOR);
            // Floor Line (Bright)
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, FLOOR, canvas.width, 4);

            // 4. Trail (Ghost Effect)
            state.player.trail.forEach(t => {
                ctx.save();
                ctx.translate(t.x + 20, t.y + 20);
                ctx.rotate(t.angle);
                ctx.globalAlpha = t.life * 0.5;
                ctx.fillStyle = "#00ff00"; // Trail color
                ctx.fillRect(-15, -15, 30, 30); // Slightly smaller
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // 5. Particles
            state.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;

            // 6. Player (Only draw if running, else invisible because exploded)
            if(state.running) {
                const p = state.player;
                ctx.save();
                ctx.translate(p.x + p.size/2, p.y + p.size/2);
                ctx.rotate(p.angle);
                
                // Outer Box (Yellow)
                ctx.fillStyle = "#ffff00"; 
                ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                
                // Inner Box (Cyan)
                ctx.fillStyle = "#00ffff"; 
                const border = 6;
                ctx.fillRect(-p.size/2 + border, -p.size/2 + border, p.size - border*2, p.size - border*2);
                
                // Face (The Classic Icon)
                ctx.fillStyle = "#000";
                // Eye
                ctx.fillRect(2, -8, 8, 8);
                // Mouth
                ctx.fillRect(2, 6, 8, 4);
                
                ctx.restore();
            }

            // 7. Obstacles
            state.obstacles.forEach(obs => {
                if(obs.type === 'spike') {
                    // Draw Spike
                    ctx.fillStyle = "#000"; // Black core
                    ctx.strokeStyle = "#fff"; // White outline
                    ctx.lineWidth = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y + obs.h);
                    ctx.lineTo(obs.x + obs.w/2, obs.y);
                    ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Inner detail
                    ctx.fillStyle = "#333";
                    ctx.beginPath();
                    ctx.moveTo(obs.x + 10, obs.y + obs.h - 5);
                    ctx.lineTo(obs.x + obs.w/2, obs.y + 15);
                    ctx.lineTo(obs.x + obs.w - 10, obs.y + obs.h - 5);
                    ctx.fill();

                } else {
                    // Draw Block
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.strokeStyle = "#00ff00"; // Neon Green outline
                    ctx.lineWidth = 2;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                    
                    // X detail
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y); ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                    ctx.moveTo(obs.x + obs.w, obs.y); ctx.lineTo(obs.x, obs.y + obs.h);
                    ctx.stroke();
                }
            });
        }

        function drawStatic() {
            // Static Menu Background
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0, BG_COLOR);
            grd.addColorStop(1, "#002244");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = FLOOR_COLOR;
            ctx.fillRect(0, FLOOR, canvas.width, canvas.height - FLOOR);
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, FLOOR, canvas.width, 4);
        }

        // --- INPUT ---
        function jump(e) {
            // Ignore clicks on button
            if(e.target.closest('#start-btn') || e.target.closest('#menu')) return;
            if(e.type !== 'keydown') e.preventDefault(); // Stop mobile scroll

            if(state.running && state.player.grounded) {
                state.player.dy = JUMP_FORCE;
                state.player.grounded = false;
            }
        }

        window.addEventListener('mousedown', jump);
        window.addEventListener('touchstart', jump, {passive: false});
        window.addEventListener('keydown', e => { if(e.code === 'Space') jump(e) });

        resize();
    </script>
</body>
</html>
